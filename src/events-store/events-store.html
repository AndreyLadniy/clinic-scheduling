<!--<script>--><!--const subscribers = [];--><!--const projections = [];--><!--const publish = (stream, event) => {--><!--projections.forEach(projection => projection(stream, event))--><!--};--><!--const when = handlers => {--><!--return {--><!--outputTo: out--><!--}--><!--};--><!--const fromStreams =  stream => {--><!--return {--><!--when: when--><!--}--><!--};--><!--var projections = {--><!--createEventProcessor: function () {--><!--var state = null;--><!--function onEvent(eventEnvelop, eventHandler) {--><!--let newSate = eventHandler(state, event);--><!--return newSate === undefined ? state : newSate;--><!--}--><!--function when(handlers) {--><!--}--><!--function sourceFromStream(stream) {--><!--return {--><!--when: {}--><!--}--><!--}--><!--return {--><!--fromStream: sourceFromStream--><!--}--><!--}--><!--};--><!--class Stream {--><!--constructor() {--><!--this.subscribers = [];--><!--}--><!--subscribe(subscriber) {--><!--this.subscribers = this.subscribers.concat(subscriber);--><!--}--><!--publish(event) {--><!--this.subscribers.forEach(el => el.receive(event));--><!--}--><!--}--><!--const mainEventsStream = new Stream();--><!--class Projection {--><!--constructor() {--><!--this.state = null;--><!--this.source = null--><!--}--><!--fromStream(stream) {--><!--this.source = new ProjectionStreamSource(stream);--><!--return this.source;--><!--}--><!--receiveEvent(stream, event) {--><!--this.source--><!--}--><!--}--><!--class ProjectionSource {--><!--constructor(projection) {--><!--this.projection = projection;--><!--}--><!--when(handlers) {--><!--}--><!--receive(event) {--><!--}--><!--}--><!--class ProjectionStreamSource extends ProjectionSource {--><!--constructor(stream) {--><!--super();--><!--stream.subscribe(this);--><!--}--><!--}--><!--IllegalArgumentException.prototype = new Error();--><!--IllegalArgumentException = {};--><!--/** Tests an expression, throwing an `IllegalArgumentException` if false.--><!--*  This method is similar to `assert`, but blames the caller of the method--><!--*  for violating the condition.--><!--*--><!--*  @param requirement   the expression to test--><!--*  @param message       a String to include in the failure message--><!--*  @group assertions--><!--*/--><!--function require(requirement, message) {--><!--if (!requirement)--><!--let m = typeof message === 'function' ? message() : message;--><!--throw new IllegalArgumentException("requirement failed: " + m)--><!--}--><!--class InPort {--><!--constructor() {--><!--this.id = -1;--><!--this.inlet = this;--><!--}--><!--}--><!--class OutPort {--><!--constructor() {--><!--this.id = -1;--><!--this.outlet = this;--><!--}--><!--}--><!--class Shape {--><!--constructor() {--><!--this.inlets = undefined;--><!--this.outlets = undefined;--><!--}--><!--}--><!--class Module {--><!--constructor() {--><!--if (new.target === Abstract) {--><!--throw new TypeError("Cannot construct Abstract instances directly");--><!--}--><!--if (this.shape === undefined) {--><!--// or maybe test typeof this.method === "function"--><!--throw new TypeError("Must override method");--><!--}--><!--//            this.shape = undefined;--><!--this._inPorts = undefined;--><!--this._OutPorts = undefined;--><!--}--><!--replaceShape(s) {--><!--return new Module();--><!--}--><!--inPorts() {--><!--if (!this._inPorts) {--><!--this._inPorts = new Set(this.shape.inlets)--><!--}--><!--return this._inPorts;--><!--}--><!--outPorts() {--><!--if (!this._outPorts) {--><!--this._outPorts = new Set(this.shape.outlets)--><!--}--><!--return this._outPorts;--><!--}--><!--isRunnable() {--><!--return this.inPorts().size === 0 && this.outPorts().size === 0;--><!--}--><!--isSink() {--><!--return this.inPorts().size === 1 && this.outPorts().size === 0;--><!--}--><!--isSource() {--><!--return this.outPorts().size === 1 && this.inPorts().size === 0;--><!--}--><!--isFlow() {--><!--return this.inPorts().size === 1 && this.outPorts().size === 1;--><!--}--><!--isBidiFlow() {--><!--return this.inPorts().size === 2 && this.outPorts().size === 2;--><!--}--><!--/*--><!--* compose[A, B, C](that: Module, f: (A, B) ⇒ C): Module--><!--* */--><!--compose(that, f) {--><!--require(that !== this, () => {return "A module cannot be added to itself. You should pass a separate instance to compose()."});--><!--}--><!--}--><!--class Source {--><!--constructor(module) {--><!--this.module = modules;--><!--}--><!--}--><!--class Flow {--><!--}--><!--</script>--><html><head></head><body></body></html>